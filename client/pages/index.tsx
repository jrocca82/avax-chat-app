import Head from "next/head";
import Image from "next/image";
import { useEffect, useState } from "react";
import styles from "../styles/Home.module.css";
import Database from "../abi/Database.json";
import { ethers } from "ethers";
import { AddNewChat, ChatCard, Message, NavBar } from "../components";
import { Button, Flex, Heading, Input, Spinner, Text } from "@chakra-ui/react";

type FriendStruct = {
	friendname: string;
	publicKey: string;
};

type MessageStruct = [string, string, string];

export default function Home() {
	const CONTRACT_ADDRESS = "0x9EbcfBD21BA17C17a24Af0B364c65454e1ee406f";
	const [friends, setFriends] = useState<[FriendStruct]>([
		{ friendname: "", publicKey: "" },
	]);
	const [myName, setMyName] = useState<string>();
	const [myPublicKey, setMyPublicKey] = useState<string>();
	const [activeChat, setActiveChat] = useState<FriendStruct>();
	const [activeChatMessages, setActiveChatMessages] = useState([]);
	const [myContract, setMyContract] = useState<ethers.Contract>();
	const [messageValue, setMessageValue] = useState<string>();

	const contractABI = Database.output.abi;
	let provider;
	let signer;

	async function connectToMetamask() {
		try {
			//@ts-ignore
			await window.ethereum.enable();
			return true;
		} catch (err) {
			return false;
		}
	}

	async function login() {
		let res = await connectToMetamask();
		if (res === true) {
			//@ts-ignore
			provider = new ethers.providers.Web3Provider(window.ethereum);
			signer = provider.getSigner();
			try {
				const contract = new ethers.Contract(
					CONTRACT_ADDRESS,
					contractABI,
					signer
				);
				setMyContract(contract);
				const address = await signer.getAddress();
				let present = await contract.checkUserExists(address);
				let username;
				if (present) username = await contract.getUsername(address);
				else {
					username = prompt("Enter a username", "Guest");
					if (username === "") username = "Guest";
					await contract.createAccount(username);
				}
				setMyName(username);
				setMyPublicKey(address);
			} catch (err) {
				alert("CONTRACT_ADDRESS not set properly!");
			}
		} else {
			alert("Couldn't connect to Metamask");
		}
	}

	async function addChat(name: string, publicKey: string) {
		try {
			let present = await myContract?.checkUserExists(publicKey);
			if (!present) {
				alert("Address not found: Ask them to join the app :)");
				return;
			}
			try {
				await myContract?.addFriend(publicKey, name);
				const frnd = { friendname: name, publicKey: publicKey };
				friends.push(frnd);
			} catch (err) {
				alert(
					"Friend already added! You can't be friends with the same person twice ;P"
				);
			}
		} catch (err) {
			alert("Invalid address!");
		}
	}

	async function sendMessage(data: string) {
		if (!(activeChat && activeChat.publicKey)) return;
		const recieverAddress = activeChat.publicKey;
		await myContract?.sendMessage(recieverAddress, data);
	}

	async function getMessage(friendsPublicKey: string) {
		let nickname;
		let messages: string[] = [];
		friends.forEach((item) => {
			if (item.publicKey === friendsPublicKey) nickname = item.friendname;
		});
		// Get messages
		const data = await myContract?.readMessage(friendsPublicKey);
		data.forEach((item: any) => {
			console.log(item);
			// const timestamp = new Date(1000 * item[1].toNumber()).toUTCString();
			// messages.push({
			//   publicKey: item[0],
			//   timeStamp: timestamp,
			//   data: item[2],
			// });
		});
		// setActiveChat({ friendname: nickname, publicKey: friendsPublicKey });
		// setActiveChatMessages(messages);
	}

	useEffect(() => {
		async function loadFriends() {
			let friendList: FriendStruct[] = [];
			// Get Friends
			const data = await myContract?.getMyFriendList();
			console.log(data);
			// data.forEach((item: any[]) => {
			// 	console.log(item);
			// });
		}
		loadFriends();
	}, [myPublicKey, myContract]);

	const Messages = activeChatMessages
		? activeChatMessages.map((message) => {
				console.log(message);
				let sender = activeChat?.friendname;
				// if (message.publicKey === myPublicKey) {
				//   margin = "15%";
				//   sender = "You";
				// }
				return (
					<Message
						sender={sender}
						key={Math.random()}
						// data={message.data}
						// timeStamp={message.timeStamp}
					/>
				);
		  })
		: null;

	const chats = friends
		? friends.map((friend) => {
				return (
					<ChatCard
						publicKey={friend.publicKey}
						name={friend.friendname}
						getMessages={(key: string) => getMessage(key)}
					/>
				);
		  })
		: null;

	return (
		<Flex
			flexDir="column"
			bgColor="black"
			color="white"
			minHeight="100vh"
			align="center"
		>
			<Head>
				<title>Create Next App</title>
				<meta name="description" content="Generated by create next app" />
				<link rel="icon" href="/favicon.ico" />
			</Head>

			<Flex w="100%">
				<NavBar login={login} username={myName} />
			</Flex>

			{myName ? (
				<>
					<Heading>Chats</Heading>
					{chats && chats.length > 1 ? (
						<Flex bgColor="white" w="80%" color="black" minHeight="300px">
							{chats}
						</Flex>
					) : (
						<Text my="20px">
							You have no chats! Click below to get started.
						</Text>
					)}

					<AddNewChat
						addHandler={(name: string, publicKey: string) =>
							addChat(name, publicKey)
						}
					/>
				</>
			) : (
				<>
					<Text mb="30px">Waiting to connect to metamask...</Text>
					<Spinner />
				</>
			)}
			{activeChat ? (
				<Flex>
					<Heading>
						{activeChat?.friendname} : {activeChat?.publicKey}{" "}
					</Heading>
					<Button
						onClick={() => {
							if (activeChat && activeChat.publicKey) {
								getMessage(activeChat.publicKey);
							}
						}}
					>
						Refresh
					</Button>
					<Flex>{Messages}</Flex>
					<Flex>
						<Input
							placeholder="Send message"
							value={messageValue}
							onChange={(e) => setMessageValue(e.target.value)}
						/>
						<Button
							onClick={() => {
								if (messageValue) sendMessage(messageValue);
							}}
						>
							Send
						</Button>
					</Flex>
				</Flex>
			) : null}
		</Flex>
	);
}
